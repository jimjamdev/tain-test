# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

type UserLoginOutput {
    email: String!
    id: String!
    image: String
    name: String!
    username: String!
}

"columns and relationships of \"accounts\""
type accounts {
    access_token: String
    access_token_expires: timestamptz
    compound_id: String!
    created_at: timestamptz!
    id: Int!
    provider_account_id: String!
    provider_id: String!
    provider_type: String!
    refresh_token: String
    updated_at: timestamptz!
    user_id: Int!
}

"aggregated selection of \"accounts\""
type accounts_aggregate {
    aggregate: accounts_aggregate_fields
    nodes: [accounts!]!
}

"aggregate fields of \"accounts\""
type accounts_aggregate_fields {
    avg: accounts_avg_fields
    count(columns: [accounts_select_column!], distinct: Boolean): Int!
    max: accounts_max_fields
    min: accounts_min_fields
    stddev: accounts_stddev_fields
    stddev_pop: accounts_stddev_pop_fields
    stddev_samp: accounts_stddev_samp_fields
    sum: accounts_sum_fields
    var_pop: accounts_var_pop_fields
    var_samp: accounts_var_samp_fields
    variance: accounts_variance_fields
}

"aggregate avg on columns"
type accounts_avg_fields {
    id: Float
    user_id: Float
}

"aggregate max on columns"
type accounts_max_fields {
    access_token: String
    access_token_expires: timestamptz
    compound_id: String
    created_at: timestamptz
    id: Int
    provider_account_id: String
    provider_id: String
    provider_type: String
    refresh_token: String
    updated_at: timestamptz
    user_id: Int
}

"aggregate min on columns"
type accounts_min_fields {
    access_token: String
    access_token_expires: timestamptz
    compound_id: String
    created_at: timestamptz
    id: Int
    provider_account_id: String
    provider_id: String
    provider_type: String
    refresh_token: String
    updated_at: timestamptz
    user_id: Int
}

"response of any mutation on the table \"accounts\""
type accounts_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [accounts!]!
}

"aggregate stddev on columns"
type accounts_stddev_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_pop on columns"
type accounts_stddev_pop_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_samp on columns"
type accounts_stddev_samp_fields {
    id: Float
    user_id: Float
}

"aggregate sum on columns"
type accounts_sum_fields {
    id: Int
    user_id: Int
}

"aggregate var_pop on columns"
type accounts_var_pop_fields {
    id: Float
    user_id: Float
}

"aggregate var_samp on columns"
type accounts_var_samp_fields {
    id: Float
    user_id: Float
}

"aggregate variance on columns"
type accounts_variance_fields {
    id: Float
    user_id: Float
}

"columns and relationships of \"listings\""
type listings {
    body: String!
    created_at: timestamptz!
    id: bigint!
    name: String!
    slug: String!
    updated_at: timestamptz!
    "An object relationship"
    user: users!
    user_id: bigint!
}

"aggregated selection of \"listings\""
type listings_aggregate {
    aggregate: listings_aggregate_fields
    nodes: [listings!]!
}

"aggregate fields of \"listings\""
type listings_aggregate_fields {
    avg: listings_avg_fields
    count(columns: [listings_select_column!], distinct: Boolean): Int!
    max: listings_max_fields
    min: listings_min_fields
    stddev: listings_stddev_fields
    stddev_pop: listings_stddev_pop_fields
    stddev_samp: listings_stddev_samp_fields
    sum: listings_sum_fields
    var_pop: listings_var_pop_fields
    var_samp: listings_var_samp_fields
    variance: listings_variance_fields
}

"aggregate avg on columns"
type listings_avg_fields {
    id: Float
    user_id: Float
}

"aggregate max on columns"
type listings_max_fields {
    body: String
    created_at: timestamptz
    id: bigint
    name: String
    slug: String
    updated_at: timestamptz
    user_id: bigint
}

"aggregate min on columns"
type listings_min_fields {
    body: String
    created_at: timestamptz
    id: bigint
    name: String
    slug: String
    updated_at: timestamptz
    user_id: bigint
}

"response of any mutation on the table \"listings\""
type listings_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [listings!]!
}

"aggregate stddev on columns"
type listings_stddev_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_pop on columns"
type listings_stddev_pop_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_samp on columns"
type listings_stddev_samp_fields {
    id: Float
    user_id: Float
}

"aggregate sum on columns"
type listings_sum_fields {
    id: bigint
    user_id: bigint
}

"aggregate var_pop on columns"
type listings_var_pop_fields {
    id: Float
    user_id: Float
}

"aggregate var_samp on columns"
type listings_var_samp_fields {
    id: Float
    user_id: Float
}

"aggregate variance on columns"
type listings_variance_fields {
    id: Float
    user_id: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"accounts\""
    delete_accounts(
        "filter the rows which have to be deleted"
        where: accounts_bool_exp!
    ): accounts_mutation_response
    "delete single row from the table: \"accounts\""
    delete_accounts_by_pk(id: Int!): accounts
    "delete data from the table: \"listings\""
    delete_listings(
        "filter the rows which have to be deleted"
        where: listings_bool_exp!
    ): listings_mutation_response
    "delete single row from the table: \"listings\""
    delete_listings_by_pk(id: bigint!): listings
    "delete data from the table: \"sessions\""
    delete_sessions(
        "filter the rows which have to be deleted"
        where: sessions_bool_exp!
    ): sessions_mutation_response
    "delete single row from the table: \"sessions\""
    delete_sessions_by_pk(id: Int!): sessions
    "delete data from the table: \"typeorm_metadata\""
    delete_typeorm_metadata(
        "filter the rows which have to be deleted"
        where: typeorm_metadata_bool_exp!
    ): typeorm_metadata_mutation_response
    "delete data from the table: \"users\""
    delete_users(
        "filter the rows which have to be deleted"
        where: users_bool_exp!
    ): users_mutation_response
    "delete single row from the table: \"users\""
    delete_users_by_pk(id: Int!): users
    "delete data from the table: \"verification_requests\""
    delete_verification_requests(
        "filter the rows which have to be deleted"
        where: verification_requests_bool_exp!
    ): verification_requests_mutation_response
    "delete single row from the table: \"verification_requests\""
    delete_verification_requests_by_pk(id: Int!): verification_requests
    "insert data into the table: \"accounts\""
    insert_accounts(
        "the rows to be inserted"
        objects: [accounts_insert_input!]!,
        "on conflict condition"
        on_conflict: accounts_on_conflict
    ): accounts_mutation_response
    "insert a single row into the table: \"accounts\""
    insert_accounts_one(
        "the row to be inserted"
        object: accounts_insert_input!,
        "on conflict condition"
        on_conflict: accounts_on_conflict
    ): accounts
    "insert data into the table: \"listings\""
    insert_listings(
        "the rows to be inserted"
        objects: [listings_insert_input!]!,
        "on conflict condition"
        on_conflict: listings_on_conflict
    ): listings_mutation_response
    "insert a single row into the table: \"listings\""
    insert_listings_one(
        "the row to be inserted"
        object: listings_insert_input!,
        "on conflict condition"
        on_conflict: listings_on_conflict
    ): listings
    "insert data into the table: \"sessions\""
    insert_sessions(
        "the rows to be inserted"
        objects: [sessions_insert_input!]!,
        "on conflict condition"
        on_conflict: sessions_on_conflict
    ): sessions_mutation_response
    "insert a single row into the table: \"sessions\""
    insert_sessions_one(
        "the row to be inserted"
        object: sessions_insert_input!,
        "on conflict condition"
        on_conflict: sessions_on_conflict
    ): sessions
    "insert data into the table: \"typeorm_metadata\""
    insert_typeorm_metadata(
        "the rows to be inserted"
        objects: [typeorm_metadata_insert_input!]!
    ): typeorm_metadata_mutation_response
    "insert a single row into the table: \"typeorm_metadata\""
    insert_typeorm_metadata_one(
        "the row to be inserted"
        object: typeorm_metadata_insert_input!
    ): typeorm_metadata
    "insert data into the table: \"users\""
    insert_users(
        "the rows to be inserted"
        objects: [users_insert_input!]!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users_mutation_response
    "insert a single row into the table: \"users\""
    insert_users_one(
        "the row to be inserted"
        object: users_insert_input!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users
    "insert data into the table: \"verification_requests\""
    insert_verification_requests(
        "the rows to be inserted"
        objects: [verification_requests_insert_input!]!,
        "on conflict condition"
        on_conflict: verification_requests_on_conflict
    ): verification_requests_mutation_response
    "insert a single row into the table: \"verification_requests\""
    insert_verification_requests_one(
        "the row to be inserted"
        object: verification_requests_insert_input!,
        "on conflict condition"
        on_conflict: verification_requests_on_conflict
    ): verification_requests
    "update data of the table: \"accounts\""
    update_accounts(
        "increments the numeric columns with given value of the filtered values"
        _inc: accounts_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: accounts_set_input,
        "filter the rows which have to be updated"
        where: accounts_bool_exp!
    ): accounts_mutation_response
    "update single row of the table: \"accounts\""
    update_accounts_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: accounts_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: accounts_set_input,
        pk_columns: accounts_pk_columns_input!
    ): accounts
    "update data of the table: \"listings\""
    update_listings(
        "increments the numeric columns with given value of the filtered values"
        _inc: listings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: listings_set_input,
        "filter the rows which have to be updated"
        where: listings_bool_exp!
    ): listings_mutation_response
    "update single row of the table: \"listings\""
    update_listings_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: listings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: listings_set_input,
        pk_columns: listings_pk_columns_input!
    ): listings
    "update data of the table: \"sessions\""
    update_sessions(
        "increments the numeric columns with given value of the filtered values"
        _inc: sessions_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: sessions_set_input,
        "filter the rows which have to be updated"
        where: sessions_bool_exp!
    ): sessions_mutation_response
    "update single row of the table: \"sessions\""
    update_sessions_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: sessions_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: sessions_set_input,
        pk_columns: sessions_pk_columns_input!
    ): sessions
    "update data of the table: \"typeorm_metadata\""
    update_typeorm_metadata(
        "sets the columns of the filtered rows to the given values"
        _set: typeorm_metadata_set_input,
        "filter the rows which have to be updated"
        where: typeorm_metadata_bool_exp!
    ): typeorm_metadata_mutation_response
    "update data of the table: \"users\""
    update_users(
        "increments the numeric columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        "filter the rows which have to be updated"
        where: users_bool_exp!
    ): users_mutation_response
    "update single row of the table: \"users\""
    update_users_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        pk_columns: users_pk_columns_input!
    ): users
    "update data of the table: \"verification_requests\""
    update_verification_requests(
        "increments the numeric columns with given value of the filtered values"
        _inc: verification_requests_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: verification_requests_set_input,
        "filter the rows which have to be updated"
        where: verification_requests_bool_exp!
    ): verification_requests_mutation_response
    "update single row of the table: \"verification_requests\""
    update_verification_requests_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: verification_requests_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: verification_requests_set_input,
        pk_columns: verification_requests_pk_columns_input!
    ): verification_requests
}

type query_root {
    "fetch data from the table: \"accounts\""
    accounts(
        "distinct select on columns"
        distinct_on: [accounts_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [accounts_order_by!],
        "filter the rows returned"
        where: accounts_bool_exp
    ): [accounts!]!
    "fetch aggregated fields from the table: \"accounts\""
    accounts_aggregate(
        "distinct select on columns"
        distinct_on: [accounts_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [accounts_order_by!],
        "filter the rows returned"
        where: accounts_bool_exp
    ): accounts_aggregate!
    "fetch data from the table: \"accounts\" using primary key columns"
    accounts_by_pk(id: Int!): accounts
    "fetch data from the table: \"listings\""
    listings(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): [listings!]!
    "fetch aggregated fields from the table: \"listings\""
    listings_aggregate(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): listings_aggregate!
    "fetch data from the table: \"listings\" using primary key columns"
    listings_by_pk(id: bigint!): listings
    "fetch data from the table: \"sessions\""
    sessions(
        "distinct select on columns"
        distinct_on: [sessions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!],
        "filter the rows returned"
        where: sessions_bool_exp
    ): [sessions!]!
    "fetch aggregated fields from the table: \"sessions\""
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [sessions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!],
        "filter the rows returned"
        where: sessions_bool_exp
    ): sessions_aggregate!
    "fetch data from the table: \"sessions\" using primary key columns"
    sessions_by_pk(id: Int!): sessions
    "fetch data from the table: \"typeorm_metadata\""
    typeorm_metadata(
        "distinct select on columns"
        distinct_on: [typeorm_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [typeorm_metadata_order_by!],
        "filter the rows returned"
        where: typeorm_metadata_bool_exp
    ): [typeorm_metadata!]!
    "fetch aggregated fields from the table: \"typeorm_metadata\""
    typeorm_metadata_aggregate(
        "distinct select on columns"
        distinct_on: [typeorm_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [typeorm_metadata_order_by!],
        "filter the rows returned"
        where: typeorm_metadata_bool_exp
    ): typeorm_metadata_aggregate!
    userLogin(email: String!, password: String!): UserLoginOutput
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: Int!): users
    "fetch data from the table: \"verification_requests\""
    verification_requests(
        "distinct select on columns"
        distinct_on: [verification_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [verification_requests_order_by!],
        "filter the rows returned"
        where: verification_requests_bool_exp
    ): [verification_requests!]!
    "fetch aggregated fields from the table: \"verification_requests\""
    verification_requests_aggregate(
        "distinct select on columns"
        distinct_on: [verification_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [verification_requests_order_by!],
        "filter the rows returned"
        where: verification_requests_bool_exp
    ): verification_requests_aggregate!
    "fetch data from the table: \"verification_requests\" using primary key columns"
    verification_requests_by_pk(id: Int!): verification_requests
}

"columns and relationships of \"sessions\""
type sessions {
    access_token: String!
    created_at: timestamptz!
    expires: timestamptz!
    id: Int!
    session_token: String!
    updated_at: timestamptz!
    user_id: Int!
}

"aggregated selection of \"sessions\""
type sessions_aggregate {
    aggregate: sessions_aggregate_fields
    nodes: [sessions!]!
}

"aggregate fields of \"sessions\""
type sessions_aggregate_fields {
    avg: sessions_avg_fields
    count(columns: [sessions_select_column!], distinct: Boolean): Int!
    max: sessions_max_fields
    min: sessions_min_fields
    stddev: sessions_stddev_fields
    stddev_pop: sessions_stddev_pop_fields
    stddev_samp: sessions_stddev_samp_fields
    sum: sessions_sum_fields
    var_pop: sessions_var_pop_fields
    var_samp: sessions_var_samp_fields
    variance: sessions_variance_fields
}

"aggregate avg on columns"
type sessions_avg_fields {
    id: Float
    user_id: Float
}

"aggregate max on columns"
type sessions_max_fields {
    access_token: String
    created_at: timestamptz
    expires: timestamptz
    id: Int
    session_token: String
    updated_at: timestamptz
    user_id: Int
}

"aggregate min on columns"
type sessions_min_fields {
    access_token: String
    created_at: timestamptz
    expires: timestamptz
    id: Int
    session_token: String
    updated_at: timestamptz
    user_id: Int
}

"response of any mutation on the table \"sessions\""
type sessions_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sessions!]!
}

"aggregate stddev on columns"
type sessions_stddev_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_pop on columns"
type sessions_stddev_pop_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_samp on columns"
type sessions_stddev_samp_fields {
    id: Float
    user_id: Float
}

"aggregate sum on columns"
type sessions_sum_fields {
    id: Int
    user_id: Int
}

"aggregate var_pop on columns"
type sessions_var_pop_fields {
    id: Float
    user_id: Float
}

"aggregate var_samp on columns"
type sessions_var_samp_fields {
    id: Float
    user_id: Float
}

"aggregate variance on columns"
type sessions_variance_fields {
    id: Float
    user_id: Float
}

type subscription_root {
    "fetch data from the table: \"accounts\""
    accounts(
        "distinct select on columns"
        distinct_on: [accounts_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [accounts_order_by!],
        "filter the rows returned"
        where: accounts_bool_exp
    ): [accounts!]!
    "fetch aggregated fields from the table: \"accounts\""
    accounts_aggregate(
        "distinct select on columns"
        distinct_on: [accounts_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [accounts_order_by!],
        "filter the rows returned"
        where: accounts_bool_exp
    ): accounts_aggregate!
    "fetch data from the table: \"accounts\" using primary key columns"
    accounts_by_pk(id: Int!): accounts
    "fetch data from the table: \"listings\""
    listings(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): [listings!]!
    "fetch aggregated fields from the table: \"listings\""
    listings_aggregate(
        "distinct select on columns"
        distinct_on: [listings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [listings_order_by!],
        "filter the rows returned"
        where: listings_bool_exp
    ): listings_aggregate!
    "fetch data from the table: \"listings\" using primary key columns"
    listings_by_pk(id: bigint!): listings
    "fetch data from the table: \"sessions\""
    sessions(
        "distinct select on columns"
        distinct_on: [sessions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!],
        "filter the rows returned"
        where: sessions_bool_exp
    ): [sessions!]!
    "fetch aggregated fields from the table: \"sessions\""
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [sessions_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!],
        "filter the rows returned"
        where: sessions_bool_exp
    ): sessions_aggregate!
    "fetch data from the table: \"sessions\" using primary key columns"
    sessions_by_pk(id: Int!): sessions
    "fetch data from the table: \"typeorm_metadata\""
    typeorm_metadata(
        "distinct select on columns"
        distinct_on: [typeorm_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [typeorm_metadata_order_by!],
        "filter the rows returned"
        where: typeorm_metadata_bool_exp
    ): [typeorm_metadata!]!
    "fetch aggregated fields from the table: \"typeorm_metadata\""
    typeorm_metadata_aggregate(
        "distinct select on columns"
        distinct_on: [typeorm_metadata_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [typeorm_metadata_order_by!],
        "filter the rows returned"
        where: typeorm_metadata_bool_exp
    ): typeorm_metadata_aggregate!
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: Int!): users
    "fetch data from the table: \"verification_requests\""
    verification_requests(
        "distinct select on columns"
        distinct_on: [verification_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [verification_requests_order_by!],
        "filter the rows returned"
        where: verification_requests_bool_exp
    ): [verification_requests!]!
    "fetch aggregated fields from the table: \"verification_requests\""
    verification_requests_aggregate(
        "distinct select on columns"
        distinct_on: [verification_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [verification_requests_order_by!],
        "filter the rows returned"
        where: verification_requests_bool_exp
    ): verification_requests_aggregate!
    "fetch data from the table: \"verification_requests\" using primary key columns"
    verification_requests_by_pk(id: Int!): verification_requests
}

"columns and relationships of \"typeorm_metadata\""
type typeorm_metadata {
    database: String
    name: String
    schema: String
    table: String
    type: String!
    value: String
}

"aggregated selection of \"typeorm_metadata\""
type typeorm_metadata_aggregate {
    aggregate: typeorm_metadata_aggregate_fields
    nodes: [typeorm_metadata!]!
}

"aggregate fields of \"typeorm_metadata\""
type typeorm_metadata_aggregate_fields {
    count(columns: [typeorm_metadata_select_column!], distinct: Boolean): Int!
    max: typeorm_metadata_max_fields
    min: typeorm_metadata_min_fields
}

"aggregate max on columns"
type typeorm_metadata_max_fields {
    database: String
    name: String
    schema: String
    table: String
    type: String
    value: String
}

"aggregate min on columns"
type typeorm_metadata_min_fields {
    database: String
    name: String
    schema: String
    table: String
    type: String
    value: String
}

"response of any mutation on the table \"typeorm_metadata\""
type typeorm_metadata_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [typeorm_metadata!]!
}

"columns and relationships of \"users\""
type users {
    created_at: timestamptz!
    email: String
    email_verified: timestamptz
    id: Int!
    image: String
    name: String
    password: String!
    updated_at: timestamptz!
    username: String
}

"aggregated selection of \"users\""
type users_aggregate {
    aggregate: users_aggregate_fields
    nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
    avg: users_avg_fields
    count(columns: [users_select_column!], distinct: Boolean): Int!
    max: users_max_fields
    min: users_min_fields
    stddev: users_stddev_fields
    stddev_pop: users_stddev_pop_fields
    stddev_samp: users_stddev_samp_fields
    sum: users_sum_fields
    var_pop: users_var_pop_fields
    var_samp: users_var_samp_fields
    variance: users_variance_fields
}

"aggregate avg on columns"
type users_avg_fields {
    id: Float
}

"aggregate max on columns"
type users_max_fields {
    created_at: timestamptz
    email: String
    email_verified: timestamptz
    id: Int
    image: String
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"aggregate min on columns"
type users_min_fields {
    created_at: timestamptz
    email: String
    email_verified: timestamptz
    id: Int
    image: String
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users!]!
}

"aggregate stddev on columns"
type users_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type users_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type users_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type users_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type users_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type users_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type users_variance_fields {
    id: Float
}

"columns and relationships of \"verification_requests\""
type verification_requests {
    created_at: timestamptz!
    expires: timestamptz!
    id: Int!
    identifier: String!
    token: String!
    updated_at: timestamptz!
}

"aggregated selection of \"verification_requests\""
type verification_requests_aggregate {
    aggregate: verification_requests_aggregate_fields
    nodes: [verification_requests!]!
}

"aggregate fields of \"verification_requests\""
type verification_requests_aggregate_fields {
    avg: verification_requests_avg_fields
    count(columns: [verification_requests_select_column!], distinct: Boolean): Int!
    max: verification_requests_max_fields
    min: verification_requests_min_fields
    stddev: verification_requests_stddev_fields
    stddev_pop: verification_requests_stddev_pop_fields
    stddev_samp: verification_requests_stddev_samp_fields
    sum: verification_requests_sum_fields
    var_pop: verification_requests_var_pop_fields
    var_samp: verification_requests_var_samp_fields
    variance: verification_requests_variance_fields
}

"aggregate avg on columns"
type verification_requests_avg_fields {
    id: Float
}

"aggregate max on columns"
type verification_requests_max_fields {
    created_at: timestamptz
    expires: timestamptz
    id: Int
    identifier: String
    token: String
    updated_at: timestamptz
}

"aggregate min on columns"
type verification_requests_min_fields {
    created_at: timestamptz
    expires: timestamptz
    id: Int
    identifier: String
    token: String
    updated_at: timestamptz
}

"response of any mutation on the table \"verification_requests\""
type verification_requests_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [verification_requests!]!
}

"aggregate stddev on columns"
type verification_requests_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type verification_requests_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type verification_requests_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type verification_requests_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type verification_requests_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type verification_requests_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type verification_requests_variance_fields {
    id: Float
}

"unique or primary key constraints on table \"accounts\""
enum accounts_constraint {
    "unique or primary key constraint"
    PK_5a7a02c20412299d198e097a8fe
    "unique or primary key constraint"
    UQ_95843cea26fc65b1a9d9b6e1d2b
}

"select columns of table \"accounts\""
enum accounts_select_column {
    "column name"
    access_token
    "column name"
    access_token_expires
    "column name"
    compound_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    provider_account_id
    "column name"
    provider_id
    "column name"
    provider_type
    "column name"
    refresh_token
    "column name"
    updated_at
    "column name"
    user_id
}

"update columns of table \"accounts\""
enum accounts_update_column {
    "column name"
    access_token
    "column name"
    access_token_expires
    "column name"
    compound_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    provider_account_id
    "column name"
    provider_id
    "column name"
    provider_type
    "column name"
    refresh_token
    "column name"
    updated_at
    "column name"
    user_id
}

"unique or primary key constraints on table \"listings\""
enum listings_constraint {
    "unique or primary key constraint"
    listings_pkey
}

"select columns of table \"listings\""
enum listings_select_column {
    "column name"
    body
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
    "column name"
    slug
    "column name"
    updated_at
    "column name"
    user_id
}

"update columns of table \"listings\""
enum listings_update_column {
    "column name"
    body
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
    "column name"
    slug
    "column name"
    updated_at
    "column name"
    user_id
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"sessions\""
enum sessions_constraint {
    "unique or primary key constraint"
    PK_3238ef96f18b355b671619111bc
    "unique or primary key constraint"
    UQ_b02a7acc05fe8194bed8433cf25
    "unique or primary key constraint"
    UQ_f10db2949bbea55b44f31108e1a
}

"select columns of table \"sessions\""
enum sessions_select_column {
    "column name"
    access_token
    "column name"
    created_at
    "column name"
    expires
    "column name"
    id
    "column name"
    session_token
    "column name"
    updated_at
    "column name"
    user_id
}

"update columns of table \"sessions\""
enum sessions_update_column {
    "column name"
    access_token
    "column name"
    created_at
    "column name"
    expires
    "column name"
    id
    "column name"
    session_token
    "column name"
    updated_at
    "column name"
    user_id
}

"select columns of table \"typeorm_metadata\""
enum typeorm_metadata_select_column {
    "column name"
    database
    "column name"
    name
    "column name"
    schema
    "column name"
    table
    "column name"
    type
    "column name"
    value
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
    "unique or primary key constraint"
    PK_a3ffb1c0c8416b9fc6f907b7433
    "unique or primary key constraint"
    UQ_97672ac88f789774dd47f7c8be3
    "unique or primary key constraint"
    users_username_key
}

"select columns of table \"users\""
enum users_select_column {
    "column name"
    created_at
    "column name"
    email
    "column name"
    email_verified
    "column name"
    id
    "column name"
    image
    "column name"
    name
    "column name"
    password
    "column name"
    updated_at
    "column name"
    username
}

"update columns of table \"users\""
enum users_update_column {
    "column name"
    created_at
    "column name"
    email
    "column name"
    email_verified
    "column name"
    id
    "column name"
    image
    "column name"
    name
    "column name"
    password
    "column name"
    updated_at
    "column name"
    username
}

"unique or primary key constraints on table \"verification_requests\""
enum verification_requests_constraint {
    "unique or primary key constraint"
    PK_c5d405ea25e8abd5b0b096a4f6f
    "unique or primary key constraint"
    UQ_77287cef70a4627091ae6d19c4d
}

"select columns of table \"verification_requests\""
enum verification_requests_select_column {
    "column name"
    created_at
    "column name"
    expires
    "column name"
    id
    "column name"
    identifier
    "column name"
    token
    "column name"
    updated_at
}

"update columns of table \"verification_requests\""
enum verification_requests_update_column {
    "column name"
    created_at
    "column name"
    expires
    "column name"
    id
    "column name"
    identifier
    "column name"
    token
    "column name"
    updated_at
}

scalar bigint

scalar timestamptz

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to filter rows from the table \"accounts\". All fields are combined with a logical 'AND'."
input accounts_bool_exp {
    _and: [accounts_bool_exp!]
    _not: accounts_bool_exp
    _or: [accounts_bool_exp!]
    access_token: String_comparison_exp
    access_token_expires: timestamptz_comparison_exp
    compound_id: String_comparison_exp
    created_at: timestamptz_comparison_exp
    id: Int_comparison_exp
    provider_account_id: String_comparison_exp
    provider_id: String_comparison_exp
    provider_type: String_comparison_exp
    refresh_token: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    user_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"accounts\""
input accounts_inc_input {
    id: Int
    user_id: Int
}

"input type for inserting data into table \"accounts\""
input accounts_insert_input {
    access_token: String
    access_token_expires: timestamptz
    compound_id: String
    created_at: timestamptz
    id: Int
    provider_account_id: String
    provider_id: String
    provider_type: String
    refresh_token: String
    updated_at: timestamptz
    user_id: Int
}

"on conflict condition type for table \"accounts\""
input accounts_on_conflict {
    constraint: accounts_constraint!
    update_columns: [accounts_update_column!]! = []
    where: accounts_bool_exp
}

"Ordering options when selecting data from \"accounts\"."
input accounts_order_by {
    access_token: order_by
    access_token_expires: order_by
    compound_id: order_by
    created_at: order_by
    id: order_by
    provider_account_id: order_by
    provider_id: order_by
    provider_type: order_by
    refresh_token: order_by
    updated_at: order_by
    user_id: order_by
}

"primary key columns input for table: accounts"
input accounts_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"accounts\""
input accounts_set_input {
    access_token: String
    access_token_expires: timestamptz
    compound_id: String
    created_at: timestamptz
    id: Int
    provider_account_id: String
    provider_id: String
    provider_type: String
    refresh_token: String
    updated_at: timestamptz
    user_id: Int
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
}

"Boolean expression to filter rows from the table \"listings\". All fields are combined with a logical 'AND'."
input listings_bool_exp {
    _and: [listings_bool_exp!]
    _not: listings_bool_exp
    _or: [listings_bool_exp!]
    body: String_comparison_exp
    created_at: timestamptz_comparison_exp
    id: bigint_comparison_exp
    name: String_comparison_exp
    slug: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    user: users_bool_exp
    user_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"listings\""
input listings_inc_input {
    id: bigint
    user_id: bigint
}

"input type for inserting data into table \"listings\""
input listings_insert_input {
    body: String
    created_at: timestamptz
    id: bigint
    name: String
    slug: String
    updated_at: timestamptz
    user: users_obj_rel_insert_input
    user_id: bigint
}

"on conflict condition type for table \"listings\""
input listings_on_conflict {
    constraint: listings_constraint!
    update_columns: [listings_update_column!]! = []
    where: listings_bool_exp
}

"Ordering options when selecting data from \"listings\"."
input listings_order_by {
    body: order_by
    created_at: order_by
    id: order_by
    name: order_by
    slug: order_by
    updated_at: order_by
    user: users_order_by
    user_id: order_by
}

"primary key columns input for table: listings"
input listings_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"listings\""
input listings_set_input {
    body: String
    created_at: timestamptz
    id: bigint
    name: String
    slug: String
    updated_at: timestamptz
    user_id: bigint
}

"Boolean expression to filter rows from the table \"sessions\". All fields are combined with a logical 'AND'."
input sessions_bool_exp {
    _and: [sessions_bool_exp!]
    _not: sessions_bool_exp
    _or: [sessions_bool_exp!]
    access_token: String_comparison_exp
    created_at: timestamptz_comparison_exp
    expires: timestamptz_comparison_exp
    id: Int_comparison_exp
    session_token: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    user_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"sessions\""
input sessions_inc_input {
    id: Int
    user_id: Int
}

"input type for inserting data into table \"sessions\""
input sessions_insert_input {
    access_token: String
    created_at: timestamptz
    expires: timestamptz
    id: Int
    session_token: String
    updated_at: timestamptz
    user_id: Int
}

"on conflict condition type for table \"sessions\""
input sessions_on_conflict {
    constraint: sessions_constraint!
    update_columns: [sessions_update_column!]! = []
    where: sessions_bool_exp
}

"Ordering options when selecting data from \"sessions\"."
input sessions_order_by {
    access_token: order_by
    created_at: order_by
    expires: order_by
    id: order_by
    session_token: order_by
    updated_at: order_by
    user_id: order_by
}

"primary key columns input for table: sessions"
input sessions_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"sessions\""
input sessions_set_input {
    access_token: String
    created_at: timestamptz
    expires: timestamptz
    id: Int
    session_token: String
    updated_at: timestamptz
    user_id: Int
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"typeorm_metadata\". All fields are combined with a logical 'AND'."
input typeorm_metadata_bool_exp {
    _and: [typeorm_metadata_bool_exp!]
    _not: typeorm_metadata_bool_exp
    _or: [typeorm_metadata_bool_exp!]
    database: String_comparison_exp
    name: String_comparison_exp
    schema: String_comparison_exp
    table: String_comparison_exp
    type: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"typeorm_metadata\""
input typeorm_metadata_insert_input {
    database: String
    name: String
    schema: String
    table: String
    type: String
    value: String
}

"Ordering options when selecting data from \"typeorm_metadata\"."
input typeorm_metadata_order_by {
    database: order_by
    name: order_by
    schema: order_by
    table: order_by
    type: order_by
    value: order_by
}

"input type for updating data in table \"typeorm_metadata\""
input typeorm_metadata_set_input {
    database: String
    name: String
    schema: String
    table: String
    type: String
    value: String
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
    _and: [users_bool_exp!]
    _not: users_bool_exp
    _or: [users_bool_exp!]
    created_at: timestamptz_comparison_exp
    email: String_comparison_exp
    email_verified: timestamptz_comparison_exp
    id: Int_comparison_exp
    image: String_comparison_exp
    name: String_comparison_exp
    password: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    username: String_comparison_exp
}

"input type for incrementing numeric columns in table \"users\""
input users_inc_input {
    id: Int
}

"input type for inserting data into table \"users\""
input users_insert_input {
    created_at: timestamptz
    email: String
    email_verified: timestamptz
    id: Int
    image: String
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
    data: users_insert_input!
    "on conflict condition"
    on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
    constraint: users_constraint!
    update_columns: [users_update_column!]! = []
    where: users_bool_exp
}

"Ordering options when selecting data from \"users\"."
input users_order_by {
    created_at: order_by
    email: order_by
    email_verified: order_by
    id: order_by
    image: order_by
    name: order_by
    password: order_by
    updated_at: order_by
    username: order_by
}

"primary key columns input for table: users"
input users_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"users\""
input users_set_input {
    created_at: timestamptz
    email: String
    email_verified: timestamptz
    id: Int
    image: String
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"Boolean expression to filter rows from the table \"verification_requests\". All fields are combined with a logical 'AND'."
input verification_requests_bool_exp {
    _and: [verification_requests_bool_exp!]
    _not: verification_requests_bool_exp
    _or: [verification_requests_bool_exp!]
    created_at: timestamptz_comparison_exp
    expires: timestamptz_comparison_exp
    id: Int_comparison_exp
    identifier: String_comparison_exp
    token: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"verification_requests\""
input verification_requests_inc_input {
    id: Int
}

"input type for inserting data into table \"verification_requests\""
input verification_requests_insert_input {
    created_at: timestamptz
    expires: timestamptz
    id: Int
    identifier: String
    token: String
    updated_at: timestamptz
}

"on conflict condition type for table \"verification_requests\""
input verification_requests_on_conflict {
    constraint: verification_requests_constraint!
    update_columns: [verification_requests_update_column!]! = []
    where: verification_requests_bool_exp
}

"Ordering options when selecting data from \"verification_requests\"."
input verification_requests_order_by {
    created_at: order_by
    expires: order_by
    id: order_by
    identifier: order_by
    token: order_by
    updated_at: order_by
}

"primary key columns input for table: verification_requests"
input verification_requests_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"verification_requests\""
input verification_requests_set_input {
    created_at: timestamptz
    expires: timestamptz
    id: Int
    identifier: String
    token: String
    updated_at: timestamptz
}
